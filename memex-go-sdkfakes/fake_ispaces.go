// This file was generated by counterfeiter
package memexgosdkfakes

import (
	"sync"

	memex "github.com/memexapp/memex-go-sdk"
)

type FakeISpaces struct {
	GetSpaceStub        func(muid string) (*memex.Space, error)
	getSpaceMutex       sync.RWMutex
	getSpaceArgsForCall []struct {
		muid string
	}
	getSpaceReturns struct {
		result1 *memex.Space
		result2 error
	}
	getSpaceReturnsOnCall map[int]struct {
		result1 *memex.Space
		result2 error
	}
	UpdateSpacesStub        func(array []*memex.Space, ownerID int64) error
	updateSpacesMutex       sync.RWMutex
	updateSpacesArgsForCall []struct {
		array   []*memex.Space
		ownerID int64
	}
	updateSpacesReturns struct {
		result1 error
	}
	updateSpacesReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateSpaceStub        func(space *memex.Space) error
	updateSpaceMutex       sync.RWMutex
	updateSpaceArgsForCall []struct {
		space *memex.Space
	}
	updateSpaceReturns struct {
		result1 error
	}
	updateSpaceReturnsOnCall map[int]struct {
		result1 error
	}
	MarkSpacesAsUnreadStub        func(muids []*string) error
	markSpacesAsUnreadMutex       sync.RWMutex
	markSpacesAsUnreadArgsForCall []struct {
		muids []*string
	}
	markSpacesAsUnreadReturns struct {
		result1 error
	}
	markSpacesAsUnreadReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateMediaStub        func(array []*memex.Media) error
	updateMediaMutex       sync.RWMutex
	updateMediaArgsForCall []struct {
		array []*memex.Media
	}
	updateMediaReturns struct {
		result1 error
	}
	updateMediaReturnsOnCall map[int]struct {
		result1 error
	}
	GetSpaceLinksStub        func(muid string) (*[]memex.Link, error)
	getSpaceLinksMutex       sync.RWMutex
	getSpaceLinksArgsForCall []struct {
		muid string
	}
	getSpaceLinksReturns struct {
		result1 *[]memex.Link
		result2 error
	}
	getSpaceLinksReturnsOnCall map[int]struct {
		result1 *[]memex.Link
		result2 error
	}
	UpdateLinksStub        func(array []*memex.Link, removeToken *string) error
	updateLinksMutex       sync.RWMutex
	updateLinksArgsForCall []struct {
		array       []*memex.Link
		removeToken *string
	}
	updateLinksReturns struct {
		result1 error
	}
	updateLinksReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeISpaces) GetSpace(muid string) (*memex.Space, error) {
	fake.getSpaceMutex.Lock()
	ret, specificReturn := fake.getSpaceReturnsOnCall[len(fake.getSpaceArgsForCall)]
	fake.getSpaceArgsForCall = append(fake.getSpaceArgsForCall, struct {
		muid string
	}{muid})
	fake.recordInvocation("GetSpace", []interface{}{muid})
	fake.getSpaceMutex.Unlock()
	if fake.GetSpaceStub != nil {
		return fake.GetSpaceStub(muid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getSpaceReturns.result1, fake.getSpaceReturns.result2
}

func (fake *FakeISpaces) GetSpaceCallCount() int {
	fake.getSpaceMutex.RLock()
	defer fake.getSpaceMutex.RUnlock()
	return len(fake.getSpaceArgsForCall)
}

func (fake *FakeISpaces) GetSpaceArgsForCall(i int) string {
	fake.getSpaceMutex.RLock()
	defer fake.getSpaceMutex.RUnlock()
	return fake.getSpaceArgsForCall[i].muid
}

func (fake *FakeISpaces) GetSpaceReturns(result1 *memex.Space, result2 error) {
	fake.GetSpaceStub = nil
	fake.getSpaceReturns = struct {
		result1 *memex.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeISpaces) GetSpaceReturnsOnCall(i int, result1 *memex.Space, result2 error) {
	fake.GetSpaceStub = nil
	if fake.getSpaceReturnsOnCall == nil {
		fake.getSpaceReturnsOnCall = make(map[int]struct {
			result1 *memex.Space
			result2 error
		})
	}
	fake.getSpaceReturnsOnCall[i] = struct {
		result1 *memex.Space
		result2 error
	}{result1, result2}
}

func (fake *FakeISpaces) UpdateSpaces(array []*memex.Space, ownerID int64) error {
	var arrayCopy []*memex.Space
	if array != nil {
		arrayCopy = make([]*memex.Space, len(array))
		copy(arrayCopy, array)
	}
	fake.updateSpacesMutex.Lock()
	ret, specificReturn := fake.updateSpacesReturnsOnCall[len(fake.updateSpacesArgsForCall)]
	fake.updateSpacesArgsForCall = append(fake.updateSpacesArgsForCall, struct {
		array   []*memex.Space
		ownerID int64
	}{arrayCopy, ownerID})
	fake.recordInvocation("UpdateSpaces", []interface{}{arrayCopy, ownerID})
	fake.updateSpacesMutex.Unlock()
	if fake.UpdateSpacesStub != nil {
		return fake.UpdateSpacesStub(array, ownerID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateSpacesReturns.result1
}

func (fake *FakeISpaces) UpdateSpacesCallCount() int {
	fake.updateSpacesMutex.RLock()
	defer fake.updateSpacesMutex.RUnlock()
	return len(fake.updateSpacesArgsForCall)
}

func (fake *FakeISpaces) UpdateSpacesArgsForCall(i int) ([]*memex.Space, int64) {
	fake.updateSpacesMutex.RLock()
	defer fake.updateSpacesMutex.RUnlock()
	return fake.updateSpacesArgsForCall[i].array, fake.updateSpacesArgsForCall[i].ownerID
}

func (fake *FakeISpaces) UpdateSpacesReturns(result1 error) {
	fake.UpdateSpacesStub = nil
	fake.updateSpacesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) UpdateSpacesReturnsOnCall(i int, result1 error) {
	fake.UpdateSpacesStub = nil
	if fake.updateSpacesReturnsOnCall == nil {
		fake.updateSpacesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSpacesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) UpdateSpace(space *memex.Space) error {
	fake.updateSpaceMutex.Lock()
	ret, specificReturn := fake.updateSpaceReturnsOnCall[len(fake.updateSpaceArgsForCall)]
	fake.updateSpaceArgsForCall = append(fake.updateSpaceArgsForCall, struct {
		space *memex.Space
	}{space})
	fake.recordInvocation("UpdateSpace", []interface{}{space})
	fake.updateSpaceMutex.Unlock()
	if fake.UpdateSpaceStub != nil {
		return fake.UpdateSpaceStub(space)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateSpaceReturns.result1
}

func (fake *FakeISpaces) UpdateSpaceCallCount() int {
	fake.updateSpaceMutex.RLock()
	defer fake.updateSpaceMutex.RUnlock()
	return len(fake.updateSpaceArgsForCall)
}

func (fake *FakeISpaces) UpdateSpaceArgsForCall(i int) *memex.Space {
	fake.updateSpaceMutex.RLock()
	defer fake.updateSpaceMutex.RUnlock()
	return fake.updateSpaceArgsForCall[i].space
}

func (fake *FakeISpaces) UpdateSpaceReturns(result1 error) {
	fake.UpdateSpaceStub = nil
	fake.updateSpaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) UpdateSpaceReturnsOnCall(i int, result1 error) {
	fake.UpdateSpaceStub = nil
	if fake.updateSpaceReturnsOnCall == nil {
		fake.updateSpaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSpaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) MarkSpacesAsUnread(muids []*string) error {
	var muidsCopy []*string
	if muids != nil {
		muidsCopy = make([]*string, len(muids))
		copy(muidsCopy, muids)
	}
	fake.markSpacesAsUnreadMutex.Lock()
	ret, specificReturn := fake.markSpacesAsUnreadReturnsOnCall[len(fake.markSpacesAsUnreadArgsForCall)]
	fake.markSpacesAsUnreadArgsForCall = append(fake.markSpacesAsUnreadArgsForCall, struct {
		muids []*string
	}{muidsCopy})
	fake.recordInvocation("MarkSpacesAsUnread", []interface{}{muidsCopy})
	fake.markSpacesAsUnreadMutex.Unlock()
	if fake.MarkSpacesAsUnreadStub != nil {
		return fake.MarkSpacesAsUnreadStub(muids)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.markSpacesAsUnreadReturns.result1
}

func (fake *FakeISpaces) MarkSpacesAsUnreadCallCount() int {
	fake.markSpacesAsUnreadMutex.RLock()
	defer fake.markSpacesAsUnreadMutex.RUnlock()
	return len(fake.markSpacesAsUnreadArgsForCall)
}

func (fake *FakeISpaces) MarkSpacesAsUnreadArgsForCall(i int) []*string {
	fake.markSpacesAsUnreadMutex.RLock()
	defer fake.markSpacesAsUnreadMutex.RUnlock()
	return fake.markSpacesAsUnreadArgsForCall[i].muids
}

func (fake *FakeISpaces) MarkSpacesAsUnreadReturns(result1 error) {
	fake.MarkSpacesAsUnreadStub = nil
	fake.markSpacesAsUnreadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) MarkSpacesAsUnreadReturnsOnCall(i int, result1 error) {
	fake.MarkSpacesAsUnreadStub = nil
	if fake.markSpacesAsUnreadReturnsOnCall == nil {
		fake.markSpacesAsUnreadReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.markSpacesAsUnreadReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) UpdateMedia(array []*memex.Media) error {
	var arrayCopy []*memex.Media
	if array != nil {
		arrayCopy = make([]*memex.Media, len(array))
		copy(arrayCopy, array)
	}
	fake.updateMediaMutex.Lock()
	ret, specificReturn := fake.updateMediaReturnsOnCall[len(fake.updateMediaArgsForCall)]
	fake.updateMediaArgsForCall = append(fake.updateMediaArgsForCall, struct {
		array []*memex.Media
	}{arrayCopy})
	fake.recordInvocation("UpdateMedia", []interface{}{arrayCopy})
	fake.updateMediaMutex.Unlock()
	if fake.UpdateMediaStub != nil {
		return fake.UpdateMediaStub(array)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateMediaReturns.result1
}

func (fake *FakeISpaces) UpdateMediaCallCount() int {
	fake.updateMediaMutex.RLock()
	defer fake.updateMediaMutex.RUnlock()
	return len(fake.updateMediaArgsForCall)
}

func (fake *FakeISpaces) UpdateMediaArgsForCall(i int) []*memex.Media {
	fake.updateMediaMutex.RLock()
	defer fake.updateMediaMutex.RUnlock()
	return fake.updateMediaArgsForCall[i].array
}

func (fake *FakeISpaces) UpdateMediaReturns(result1 error) {
	fake.UpdateMediaStub = nil
	fake.updateMediaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) UpdateMediaReturnsOnCall(i int, result1 error) {
	fake.UpdateMediaStub = nil
	if fake.updateMediaReturnsOnCall == nil {
		fake.updateMediaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateMediaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) GetSpaceLinks(muid string) (*[]memex.Link, error) {
	fake.getSpaceLinksMutex.Lock()
	ret, specificReturn := fake.getSpaceLinksReturnsOnCall[len(fake.getSpaceLinksArgsForCall)]
	fake.getSpaceLinksArgsForCall = append(fake.getSpaceLinksArgsForCall, struct {
		muid string
	}{muid})
	fake.recordInvocation("GetSpaceLinks", []interface{}{muid})
	fake.getSpaceLinksMutex.Unlock()
	if fake.GetSpaceLinksStub != nil {
		return fake.GetSpaceLinksStub(muid)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getSpaceLinksReturns.result1, fake.getSpaceLinksReturns.result2
}

func (fake *FakeISpaces) GetSpaceLinksCallCount() int {
	fake.getSpaceLinksMutex.RLock()
	defer fake.getSpaceLinksMutex.RUnlock()
	return len(fake.getSpaceLinksArgsForCall)
}

func (fake *FakeISpaces) GetSpaceLinksArgsForCall(i int) string {
	fake.getSpaceLinksMutex.RLock()
	defer fake.getSpaceLinksMutex.RUnlock()
	return fake.getSpaceLinksArgsForCall[i].muid
}

func (fake *FakeISpaces) GetSpaceLinksReturns(result1 *[]memex.Link, result2 error) {
	fake.GetSpaceLinksStub = nil
	fake.getSpaceLinksReturns = struct {
		result1 *[]memex.Link
		result2 error
	}{result1, result2}
}

func (fake *FakeISpaces) GetSpaceLinksReturnsOnCall(i int, result1 *[]memex.Link, result2 error) {
	fake.GetSpaceLinksStub = nil
	if fake.getSpaceLinksReturnsOnCall == nil {
		fake.getSpaceLinksReturnsOnCall = make(map[int]struct {
			result1 *[]memex.Link
			result2 error
		})
	}
	fake.getSpaceLinksReturnsOnCall[i] = struct {
		result1 *[]memex.Link
		result2 error
	}{result1, result2}
}

func (fake *FakeISpaces) UpdateLinks(array []*memex.Link, removeToken *string) error {
	var arrayCopy []*memex.Link
	if array != nil {
		arrayCopy = make([]*memex.Link, len(array))
		copy(arrayCopy, array)
	}
	fake.updateLinksMutex.Lock()
	ret, specificReturn := fake.updateLinksReturnsOnCall[len(fake.updateLinksArgsForCall)]
	fake.updateLinksArgsForCall = append(fake.updateLinksArgsForCall, struct {
		array       []*memex.Link
		removeToken *string
	}{arrayCopy, removeToken})
	fake.recordInvocation("UpdateLinks", []interface{}{arrayCopy, removeToken})
	fake.updateLinksMutex.Unlock()
	if fake.UpdateLinksStub != nil {
		return fake.UpdateLinksStub(array, removeToken)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateLinksReturns.result1
}

func (fake *FakeISpaces) UpdateLinksCallCount() int {
	fake.updateLinksMutex.RLock()
	defer fake.updateLinksMutex.RUnlock()
	return len(fake.updateLinksArgsForCall)
}

func (fake *FakeISpaces) UpdateLinksArgsForCall(i int) ([]*memex.Link, *string) {
	fake.updateLinksMutex.RLock()
	defer fake.updateLinksMutex.RUnlock()
	return fake.updateLinksArgsForCall[i].array, fake.updateLinksArgsForCall[i].removeToken
}

func (fake *FakeISpaces) UpdateLinksReturns(result1 error) {
	fake.UpdateLinksStub = nil
	fake.updateLinksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) UpdateLinksReturnsOnCall(i int, result1 error) {
	fake.UpdateLinksStub = nil
	if fake.updateLinksReturnsOnCall == nil {
		fake.updateLinksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateLinksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeISpaces) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getSpaceMutex.RLock()
	defer fake.getSpaceMutex.RUnlock()
	fake.updateSpacesMutex.RLock()
	defer fake.updateSpacesMutex.RUnlock()
	fake.updateSpaceMutex.RLock()
	defer fake.updateSpaceMutex.RUnlock()
	fake.markSpacesAsUnreadMutex.RLock()
	defer fake.markSpacesAsUnreadMutex.RUnlock()
	fake.updateMediaMutex.RLock()
	defer fake.updateMediaMutex.RUnlock()
	fake.getSpaceLinksMutex.RLock()
	defer fake.getSpaceLinksMutex.RUnlock()
	fake.updateLinksMutex.RLock()
	defer fake.updateLinksMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeISpaces) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ memex.ISpaces = new(FakeISpaces)
